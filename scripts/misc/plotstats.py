#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# @file scripts/misc/plotstats.py
#
# @author Hiroyuki Chishiro
#
# Copyright (C) 2010-2011 Ahmed S. Darwish <darwish.07@gmail.com>
# Python-2.6 _AND_ Python3.0+ compatible
#
# Usage: $script nr-of-cpus [option] < KERNEL-SCHEDULER-STATS.txt
#
# Generate a gnuplot script for plotting desired kthread properties
# over runtime. Input is taken from the raw scheduler statistics, which
# are in turn captured from the kernel's COM1 serial port output.
#
# Options:
#       'rt': plot total threads runtime over time
#       'pr': plot thread priorities change over time
#       'rq': plot cumulative threads wait in runqueues
#       None: equivalent to 'rt'
#
"""
plot desired kthread properties over runtime.
"""

import sys
import re

def usage():
  """
  usage for plotstats.py
  """
  usage_str = '{0} nr-of-cpus [rt|pr|rq] < KERNEL-SCHEDULER-STATS.txt\n'
  sys.stderr.write('Usage: ' + usage_str.format(sys.argv[0]))
  sys.exit(-1)

sys.argv.append('rt')                   # Default plotting option
if not sys.argv[1].isdigit():
  usage()
if sys.argv[2] not in ['rt', 'pr', 'rq']:
  usage()

ARGV_PNAME = sys.argv[0]
ARGV_NCPUS = sys.argv[1]
ARGV_YAXIS = sys.argv[2]
PLOT_TITLE = ''
GNUPLOT_SCRIPT = 'plot.gp'

#
# The kernel passes thread statistics, line-by-line, in below form:
# ^TicksSinceBoot[[:space:]]\
#  (ThreadID:ThreadPriority:OverallRuntime:AvgRuntime:OverallRunqueueWait:\
#   AvgRunqueuWait:NrHighPrioPreempts:NrSliceEndPreempts[[:space:]])+$
# where each line represents the state of the system after 'TicksSinceBoot'
# system ticks, and every value is in the form: '[[:digit:]]+'.
#
# Note that:
# a) A trailing white space exists after each line
# b) Threads ordering is _not_ consistent accross lines. For example, one
#    line may have:
#    <Ticks>  1:... 2:... 3:...
#    while another may contain:
#    <Ticks>  3:... 1:... 2:...
#    where the [123] digits represent 'ThreadID' in the regex above.
# c) In the SMP case, several lines with the same 'TicksSinceBoot' will
#    exist, representing each CPU state at its given tick. Due to concurr-
#    ent execution, such lines aren't ordered by any means! An example:
#    <11000>  1:... 2:... 3:...         (1)
#    <10000>  4:... 5:... 6:...         (2)
#    <10500>  6:... 5:... 4:...         (3)
#    <11000>  7:... 8:... 9:...         (4)
#    where lines (1) and (4) represent different CPUs at their 11000s tick,
#    while lines (2) and (3) represent a single core at different points of
#    time (assuming no thread migration or termination).
#
# The above grammar may seem idiotic, but it's done to simplify the
# scheduler statistics code as far as possible. Such code is executed in
# the kernel's hottest path: the ticks handler.
#

class ThreadStats:
  """
  Thread status information.
  """
  def __init__(self):
    self.priority = -1              # (Undefined-priority flag)
    self.runtime = 0                # Maximize for throughput
    self.runtime_avg = 0
    self.runqueue_wait = 0
    self.runqueue_wait_avg = 0      # Minimize for latency
    self.preempt_high_prio = 0
    self.preempt_slice_end = 0

  def get_priority(self):
    "get priority"
    return self.priority
  def get_runtime(self):
    "get runtime"
    return self.runtime
  def get_runtime_avg(self):
    "get runtime_avg"
    return self.runtime_avg
  def get_runqueue_wait(self):
    "get runqueue_wait"
    return self.runqueue_wait
  def get_runqueue_wait_avg(self):
    "get runqueue_wait_avg"
    return self.runqueue_wait_avg
  def get_preempt_high_prio(self):
    "get preempt_high_prio"
    return self.preempt_high_prio
  def get_preempt_slice_end(self):
    "get preempt_slice_end"
    return self.preempt_slice_end
  def set_priority(self, priority):
    "set priority"
    self.priority = priority
  def set_runtime(self, runtime):
    "set runtime"
    self.runtime = runtime
  def set_runtime_avg(self, runtime_avg):
    "set runtime_avg"
    self.runtime_avg = runtime_avg
  def set_runqueue_wait(self, runqueue_wait):
    "set runqueue_wait"
    self.runqueue_wait = runqueue_wait
  def set_runqueue_wait_avg(self, runqueue_wait_avg):
    "set runqueue_wait_avg"
    self.runqueue_wait_avg = runqueue_wait_avg
  def set_preempt_high_prio(self, preempt_high_prio):
    "set preempt_high_prio"
    self.preempt_high_prio = preempt_high_prio
  def set_preempt_slice_end(self, preempt_slice_end):
    "set preempt_slice_end"
    self.preempt_slice_end = preempt_slice_end


OUTFILE = open('formatted-com1-output.txt', 'w')
OUTFILE.write('# Values generated by {0}\n'.format(ARGV_PNAME))

THREADS = {}
PIDS = set()
def process_line(tick_val, tokens):
  """
  process line.
  """
  re2 = re.compile(':')
  for token in tokens:
    if token.isspace(): # trailing whitespace
      break
    attrs = re2.split(token) # <id:priority:rt:...>
    pid = int(attrs[0])
    thread_val = THREADS[frozenset([tick_val, pid])] = ThreadStats()
    thread_val.priority = int(attrs[1])
    thread_val.runtime = int(attrs[2])
    thread_val.runqueue_wait = int(attrs[4])
    PIDS.add(pid)

NR_OF_CPUS = {}
for line in sys.stdin:
  r1 = re.compile(' ')
  line_tokens = r1.split(line)        # tick <thread-attrs> <thread-attrs> ..
  tick = line_tokens[0]
  process_line(tick, line_tokens[1:])
  try:
    NR_OF_CPUS[tick] += 1
  except KeyError:
    NR_OF_CPUS[tick] = 1

  # If all CPUs have reported their state at given tick:
  if NR_OF_CPUS[tick] == int(ARGV_NCPUS):
    OUTFILE.write(tick + ' ')
    for i in sorted(PIDS):
      # After getting 'process termination' support, we can put
      # a 'gnuplot' NULL mark in a column if its [tick,pid] key
      # combination triggers a KeyError exception.
      thread = THREADS[frozenset([tick, i])]
      {
        'rt': lambda: OUTFILE.write('{0} '.format(thread.runtime)),
        'pr': lambda: OUTFILE.write('{0} '.format(thread.priority)),
        'rq': lambda: OUTFILE.write('{0} '.format(thread.runqueue_wait)),
      }[ARGV_YAXIS]()
      OUTFILE.write('\n')

PLOT_YLABEL = {
  'rt': 'Total thread runtime in ticks (HZ = 250)',
  'pr': 'Thread priority (smaller values are less favorable)',
  'rq': 'Cumulative thread wait in runqueues (ticks)'
}
PLOT_SCRIPT = '# Script generated by {0}\n'.format(ARGV_PNAME)
PLOT_SCRIPT += 'set title "{0}"\n'.format(PLOT_TITLE)
PLOT_SCRIPT += 'set xlabel "Kernel runtime in ticks (HZ = 250)"\n'
PLOT_SCRIPT += 'set ylabel "{0}"\n'.format(PLOT_YLABEL[ARGV_YAXIS])
PLOT_SCRIPT += 'set key right bottom\n'
PLOT_SCRIPT += 'set grid back\n'
PLOT_SCRIPT += 'set style data linespoints\n'
PLOT_SCRIPT += 'plot "{0}" using 1:2 title "T0"'.format(OUTFILE.name)
MAX_PID = sorted(PIDS)[-1]
for i in range(3, MAX_PID + 3):
  PLOT_SCRIPT += ',\\\n "{0}" using 1:{1} title "T{2}"'.\
                 format(OUTFILE.name, i, i - 2)
PLOT_SCRIPT += '\n'

SCRIPT_FILE = open(GNUPLOT_SCRIPT, 'w')
SCRIPT_FILE.write(PLOT_SCRIPT)

#
# Use these extra commands for GIF output:
# PLOT_SCRIPT += 'set terminal gif size 1600,1000;'
# PLOT_SCRIPT += 'set xtics 1250;'
# PLOT_SCRIPT += 'set output "graph.gif";'
# PLOT_SCRIPT += 'replot;'
#
