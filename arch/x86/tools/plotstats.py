#!/usr/bin/env python
#
# Copyright (C) 2010-2011 Ahmed S. Darwish <darwish.07@gmail.com>
# Python-2.6 _AND_ Python3.0+ compatible
#
# Usage: $script nr-of-cpus [option] < KERNEL-SCHEDULER-STATS.txt
#
# Generate a gnuplot script for plotting desired kthread properties
# over runtime. Input is taken from the raw scheduler statistics, which
# are in turn captured from the kernel's COM1 serial port output.
#
# Options:
#       'rt': plot total threads runtime over time
#       'pr': plot thread priorities change over time
#       'rq': plot cumulative threads wait in runqueues
#       None: equivalent to 'rt'
#

import sys, re

def usage():
    usage = '{0} nr-of-cpus [rt|pr|rq] < KERNEL-SCHEDULER-STATS.txt\n'
    sys.stderr.write('Usage: ' + usage.format(sys.argv[0]))
    sys.exit(-1)

sys.argv.append('rt')                   # Default plotting option
if not sys.argv[1].isdigit():
    usage();
if sys.argv[2] not in ['rt', 'pr', 'rq']:
    usage()

argv_pname = sys.argv[0]
argv_ncpus = sys.argv[1]
argv_yaxis = sys.argv[2]
plot_title = ''
gnuplot_script = 'plot.gp'

#
# The kernel passes thread statistics, line-by-line, in below form:
# ^TicksSinceBoot[[:space:]]\
#  (ThreadID:ThreadPriority:OverallRuntime:AvgRuntime:OverallRunqueueWait:\
#   AvgRunqueuWait:NrHighPrioPreempts:NrSliceEndPreempts[[:space:]])+$
# where each line represents the state of the system after 'TicksSinceBoot'
# system ticks, and every value is in the form: '[[:digit:]]+'.
#
# Note that:
# a) A trailing white space exists after each line
# b) Threads ordering is _not_ consistent accross lines. For example, one
#    line may have:
#    <Ticks>  1:... 2:... 3:... 
#    while another may contain:
#    <Ticks>  3:... 1:... 2:... 
#    where the [123] digits represent 'ThreadID' in the regex above.
# c) In the SMP case, several lines with the same 'TicksSinceBoot' will
#    exist, representing each CPU state at its given tick. Due to concurr-
#    ent execution, such lines aren't ordered by any means! An example:
#    <11000>  1:... 2:... 3:...         (1)
#    <10000>  4:... 5:... 6:...         (2)
#    <10500>  6:... 5:... 4:...         (3)
#    <11000>  7:... 8:... 9:...         (4)
#    where lines (1) and (4) represent different CPUs at their 11000s tick,
#    while lines (2) and (3) represent a single core at different points of
#    time (assuming no thread migration or termination).
#
# The above grammar may seem idiotic, but it's done to simplify the
# scheduler statistics code as far as possible. Such code is executed in
# the kernel's hottest path: the ticks handler.
#

class ThreadStats:
    def __init__(self):
        self.priority = -1              # (Undefined-priority flag)
        self.runtime = 0                # Maximize for throughput
        self.runtime_avg = 0
        self.runqueue_wait = 0
        self.runqueue_wait_avg = 0      # Minimize for latency
        self.preempt_high_prio = 0
        self.preempt_slice_end = 0

outfile = open('formatted-com1-output.txt', 'w')
outfile.write('# Values generated by {0}\n'.format(argv_pname))

threads = {}
pids = set()
def process_line(tick, tokens):
    r2 = re.compile(':')
    for token in tokens:
        if token.isspace(): break       # trailing whitespace
        attrs = r2.split(token)         # <id:priority:rt:...>
        pid = int(attrs[0])
        thread = threads[frozenset([tick,pid])] = ThreadStats()
        thread.priority = int(attrs[1])
        thread.runtime = int(attrs[2])
        thread.runqueue_wait = int(attrs[4])
        pids.add(pid)

nr_of_cpus = {}
for line in sys.stdin:
    r1 = re.compile(' ')
    line_tokens = r1.split(line)        # tick <thread-attrs> <thread-attrs> ..
    tick = line_tokens[0]
    process_line(tick, line_tokens[1:])
    try: nr_of_cpus[tick] += 1
    except KeyError: nr_of_cpus[tick] = 1

    # If all CPUs have reported their state at given tick:
    if nr_of_cpus[tick] == int(argv_ncpus):
        outfile.write(tick + ' ')
        for i in sorted(pids):
            # After getting 'process termination' support, we can put
            # a 'gnuplot' NULL mark in a column if its [tick,pid] key
            # combination triggers a KeyError exception.
            thread = threads[frozenset([tick,i])]
            {
            'rt': lambda: outfile.write('{0} '.format(thread.runtime)),
            'pr': lambda: outfile.write('{0} '.format(thread.priority)),
            'rq': lambda: outfile.write('{0} '.format(thread.runqueue_wait)),
            } [argv_yaxis]()
        outfile.write('\n')

plot_ylabel = {
    'rt': 'Total thread runtime in ticks (HZ = 250)',
    'pr': 'Thread priority (smaller values are less favorable)',
    'rq': 'Cumulative thread wait in runqueues (ticks)'
    }
plot_script = '# Script generated by {0}\n'.format(argv_pname)
plot_script += 'set title "{0}"\n'.format(plot_title)
plot_script += 'set xlabel "Kernel runtime in ticks (HZ = 250)"\n'
plot_script += 'set ylabel "{0}"\n'.format(plot_ylabel[argv_yaxis])
plot_script += 'set key right bottom\n'
plot_script += 'set grid back\n'
plot_script += 'set style data linespoints\n'
plot_script += 'plot "{0}" using 1:2 title "T0"'.format(outfile.name)
max_pid = sorted(pids)[-1]
for i in range(3, max_pid + 3):
    plot_script += ',\\\n "{0}" using 1:{1} title "T{2}"'.\
        format(outfile.name, i, i - 2)
plot_script += '\n'

script_file = open(gnuplot_script, 'w')
script_file.write(plot_script)

#
# Use these extra commands for GIF output:
# plot_script += 'set terminal gif size 1600,1000;'
# plot_script += 'set xtics 1250;'
# plot_script += 'set output "graph.gif";'
# plot_script += 'replot;'
#
